Flooring Mastery Project
--------------------------------------------------------------------------------------------------------

User Stories:
--------------------------------------------------------------------------------------------------------
1. Display orders
    1.1. ask for orderDate, then display the Orders for that date
    1.2. if no orders exist for that date, display an error message and return the user to the main menu.
2. Add an order
    2.1. orderDate - must be in the future
    2.2. customerName - may not be blank and is limited to characters [a-z][0-9] as well as periods and comma characters
    2.3. state  - entered states must be checked against the tax file.
                     - if the state does not exist in the tax file, we cannot sell there.
                     - if the tax file is modified to include the state, it should be allowed without changing the application code.
    2.4. productType - show a list of available products and pricing information to choose from
                     - if a product is added to the file it should show up in the application without a code change.
    2.5. area - must be a positive decimal (minimum is 100 sq ft)
    2.6. the remaining fields are calculated from the user entry and the tax/product information in the files.
    2.7. once calculations are complete, show the order's summary of the order and ask the user to confirm they want to place the order (Y/N).
               -  If yes, the data will be added to in-memory storage. If no, simply return to the main menu.
    2.8. orderNumber - generated by system
3. Edit an order
    3.1. ask the user for a date and order number
    3.2. if the order exists for that date, it will ask the user for each piece of order data but display the existing data.
        - if the user enters something new, it will replace that data;
        - if the user hits enter without entering any data, it will leave the data as-is
    3.3.  Only certain data is allowed to be changed: customerName, state, productType, area
        - if the state, product type, or area are changed, the order will need to be recalculated
    3.4. After querying for each editable field display a summary of the new order information and prompt for whether the edit should be saved.
            - If yes, replace the data in the file then return to the main menu.
            - If no, do not save and return to the main menu.
4. Remove an order
    4.1. the system should ask for the date and order number
    4.2. if it exists, the system should display the order information and prompt the user if they are sure.
                -if yes, it should be removed from the list (and return to the main menu)
5. Export the data
    5.1. if user selects this option, the system should export all existing data to a file
6. Quit - exit the program

Optional - Selecting this option should save all active orders files to a file called DataExport.txt within a Backup folder.
         - Exporting the order data multiple times should overwrite the data within the file with the latest active order information.
         - However, an order's line item in this DataExport file should also include the date in MM-DD-YYYY format, and the file's header should reflect this addition.
-------------------------------------------------------------------------------------------------------------------------------------------------


Entities - Classes
--------------------------------------------------------------------------------------------------------------------------------------------------

   Order                                                Product                                                 Tax
---------------------------------------               ------------------------                           --------------------------
                                                       // 1. productId - int                                  // 1. taxId - int
1. orderNumber – Integer                                2. productType - String                             2. stateAbbreviation - String
2. customerName – String                                3. costPerSquareFoot - BigDecimal                   3. stateName - String
3. state – String   (--Tax.stateAbbreviation--)         4. laborCostPerSquareFoot - BigDecimal              4. taxRate - BigDecimal
4. taxRate – BigDecimal (--Tax.taxRate--)
5. productType – String  (--Product.productType--)
6. Area – BigDecimal
7. costPerSquareFoot – BigDecimal (--Product.costPerSquareFoot--)
8. LaborCostPerSquareFoot – BigDecimal (--Product.laborCostPerSquareFoot--)
9. materialCost – BigDecimal (= area * costPerSquareFoot)
10. laborCost – BigDecimal (=area * laborCostPerSquareFoot)
11. tax – BigDecimal  ( = (materialCost + laborCost) * (taxRate/100)
12. Total – BigDecimal (= materialCost +laborCost + tax)



Packages - layers
----------------------------------------------------------------------------------------------------------------------------------------------------

model: orderDTO, productDTO, taxDTO
       (contains: private var, constructors, public getters/setters,toString,equals,hashcode)


dao: orderDAO (interface), orderDAOImpl, productDAO(interface), productDAOImpl, taxDAO, taxDAOImpl

service: orderService (interface), orderServiceImpl
       - (could have had 3 distinct service layers for each DTO but have decided to keep only one, seeing that the productDTO and taxDTO are only read from file and not nothing else)

view: orderView